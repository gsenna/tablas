// Compiled by ClojureScript 1.9.89 {:static-fns true, :optimize-constants true}
goog.provide('ui.csd_orc');
goog.require('cljs.core');
/**
 * UDO by Steven Yi,
 *   https://github.com/kunstmusik/libsyi
 */
ui.csd_orc.patter_sequencer = "\n/* uses global 128 x 8 x 16 k-array\n   128 patterns, each pattern made up of 8x16 sequences\n   atrigger signal drives each pattern\n   kpattern_indx denotes which index to play\n\n   pattern array is global for efficiency as otherwise\n   arrays would be copied every k-pass\n   */\n  \ngkpattern_sequencer_all[] init 128 * 8 * 16\n\nopcode patternseq_seqsig, a, aak\n  agate, astartIndx, klen xin\n\n  aout init 0\n  kpatindx init 15 \n\n  kindx = 0\n  while (kindx < ksmps) do\n    if(agate[kindx] == 1) then \n      kpatindx = (kpatindx + 1) % klen \n    endif\n    kstartIndx = astartIndx[kindx]\n    aout[kindx] = gkpattern_sequencer_all[kstartIndx + kpatindx]\n    kindx += 1\n  od\n\n  xout aout\n\nendop\n\nopcode pattern_sequencer, aaaaaaaa, aa\n  atrigger, apattern_indx xin\n\n  apatstart = apattern_indx * 128\n\n  a1 patternseq_seqsig atrigger, apatstart, 16 \n  a2 patternseq_seqsig atrigger, apatstart + 16, 16 \n  a3 patternseq_seqsig atrigger, apatstart + 32, 16\n  a4 patternseq_seqsig atrigger, apatstart + 48, 16\n  a5 patternseq_seqsig atrigger, apatstart + 64, 16\n  a6 patternseq_seqsig atrigger, apatstart + 80, 16\n  a7 patternseq_seqsig atrigger, apatstart + 96, 16\n  a8 patternseq_seqsig atrigger, apatstart + 112, 16\n\n  xout a1, a2, a3, a4, a5, a6, a7, a8\nendop\n\ninstr set_pat_seq_instr\n  ipatNum = p4\n  iseqnum = p5\n\n  indx = p4 * 128 + iseqnum * 16 \n  prints \"Setting pattern %d sequence %d\\n\", p4, p5 \n  gkpattern_sequencer_all[indx] = p6\n  gkpattern_sequencer_all[indx + 1] = p7\n  gkpattern_sequencer_all[indx + 2] = p8\n  gkpattern_sequencer_all[indx + 3] = p9\n  gkpattern_sequencer_all[indx + 4] = p10\n  gkpattern_sequencer_all[indx + 5] = p11\n  gkpattern_sequencer_all[indx + 6] = p12\n  gkpattern_sequencer_all[indx + 7] = p13\n  gkpattern_sequencer_all[indx + 8] = p14\n  gkpattern_sequencer_all[indx + 9] = p15\n  gkpattern_sequencer_all[indx + 10] = p16\n  gkpattern_sequencer_all[indx + 11] = p17\n  gkpattern_sequencer_all[indx + 12] = p18\n  gkpattern_sequencer_all[indx + 13] = p19\n  gkpattern_sequencer_all[indx + 14] = p20\n  gkpattern_sequencer_all[indx + 15] = p21\n\n  turnoff\nendin\n\n\nopcode set_pattern_seq, 0,iiiiiiiiiiiiiiiiii\n ipat, iseq, i0, i1, i2, i3, i4, i5 ,i6, i7, \\\n i8, i9, i10, i11, i12, i13, i14, i15 xin\n  event_i \"i\", \"set_pat_seq_instr\", 0, 1, \\\n   ipat, iseq, i0, i1, i2, i3, i4, i5 ,i6, i7, \\\n   i8, i9, i10, i11, i12, i13, i14, i15\nendop\n\ninstr copy_pat_seq_instr\n\n  isrcpat_num = p4\n  isrcseq_num = p5\n  idestpat_num = p6\n  idestseq_num = p7\n\n  indx0 = isrcpat_num * 128 + isrcseq_num * 16 \n  indx1 = idestpat_num * 128 + idestseq_num * 16 \n\n  prints \"Copying pattern %d sequence %d\\n to pattern %d sequence %d\\n\", p4, p5, p6, p7\n  gkpattern_sequencer_all[indx1]      = gkpattern_sequencer_all[indx0]     \n  gkpattern_sequencer_all[indx1 + 1]  = gkpattern_sequencer_all[indx0 + 1] \n  gkpattern_sequencer_all[indx1 + 2]  = gkpattern_sequencer_all[indx0 + 2] \n  gkpattern_sequencer_all[indx1 + 3]  = gkpattern_sequencer_all[indx0 + 3] \n  gkpattern_sequencer_all[indx1 + 4]  = gkpattern_sequencer_all[indx0 + 4] \n  gkpattern_sequencer_all[indx1 + 5]  = gkpattern_sequencer_all[indx0 + 5] \n  gkpattern_sequencer_all[indx1 + 6]  = gkpattern_sequencer_all[indx0 + 6] \n  gkpattern_sequencer_all[indx1 + 7]  = gkpattern_sequencer_all[indx0 + 7] \n  gkpattern_sequencer_all[indx1 + 8]  = gkpattern_sequencer_all[indx0 + 8] \n  gkpattern_sequencer_all[indx1 + 9]  = gkpattern_sequencer_all[indx0 + 9] \n  gkpattern_sequencer_all[indx1 + 10] = gkpattern_sequencer_all[indx0 + 10]\n  gkpattern_sequencer_all[indx1 + 11] = gkpattern_sequencer_all[indx0 + 11]\n  gkpattern_sequencer_all[indx1 + 12] = gkpattern_sequencer_all[indx0 + 12]\n  gkpattern_sequencer_all[indx1 + 13] = gkpattern_sequencer_all[indx0 + 13]\n  gkpattern_sequencer_all[indx1 + 14] = gkpattern_sequencer_all[indx1 + 14]\n  gkpattern_sequencer_all[indx1 + 15] = gkpattern_sequencer_all[indx0 + 15]\n\n  turnoff\nendin\n\n/* copies sequence from one pattern to another \n   Arguments: isrcpat, isrcseq, idestpat, idestseq\n   */\nopcode copy_pattern_seq, 0, iiii\n  ip0, is0, ip1, is1 xin\n  event_i \"i\", \"copy_pat_seq_instr\", 0, 1, ip0, is0, ip1, is1\nendop\n\nopcode clock_div, a, ak\n  atrig, kdiv xin\n  kcount init 1000 \n  asig init 0\n  kndx = 0\n  while (kndx < ksmps) do\n    if(atrig[kndx] == 1) then\n      kcount += 1\n      if(kcount >= kdiv) then\n        asig[kndx] = 1\n        kcount = 0\n      else\n        asig[kndx] = 0\n      endif\n    else\n      asig[kndx] = 0\n    endif\n    kndx += 1\n  od\n  xout asig\nendop\n\nopcode adsr140_calc_coef, k, kk\n  \n  knum_samps, kratio xin\n  xout exp( -log((1.0 + kratio) / kratio) / knum_samps)\n    \nendop\n\n/* Gated, Re-triggerable ADSR modeled after the Doepfer A-140 */\nopcode adsr140, a, aakkkk\n\nagate, aretrig, kattack, kdecay, ksustain, krelease xin\n\nkstate init 0  ; 0 = attack, 1 = decay, 2 = sustain\nklasttrig init -1\nkval init 0.0\nasig init 0\nkindx = 0\n\nkattack_base init 0\nkdecay_base init 0\nkrelease_base init 0\n\nkattack_samps init 0\nkdecay_samps init 0\nkrelease_samps init 0\n\nkattack_coef init 0\nkdecay_coef init 0\nksustain_coef init 0\n\nklast_attack init -1\nklast_decay init -1\nklast_release init -1\n\nif (klast_attack != kattack) then\n  klast_attack = kattack\n  kattack_samps = kattack * sr\n  kattack_coef = adsr140_calc_coef(kattack_samps, 0.3)\n  kattack_base = (1.0 + 0.3) * (1 - kattack_coef)\nendif\n\nif (klast_decay != kdecay) then\n  klast_decay = kdecay\n  kdecay_samps = kdecay * sr\n  kdecay_coef = adsr140_calc_coef(kdecay_samps, 0.0001)\n  kdecay_base = (ksustain - 0.0001) * (1.0 - kdecay_coef)\nendif\n\nif (klast_release != krelease) then\n  klast_release = krelease\n  krelease_samps = krelease * sr\n  krelease_coef = adsr140_calc_coef(krelease_samps, 0.0001)\n  krelease_base =  -0.0001 * (1.0 - krelease_coef)\nendif\n\n\nwhile (kindx < ksmps) do\n  if (agate[kindx] > 0) then\n    kretrig = aretrig[kindx]\n    if (kretrig > 0 && klasttrig <= 0) then\n      kstate = 0\n    endif\n    klasttrig = kretrig\n\n    if (kstate == 0) then\n      kval = kattack_base + (kval * kattack_coef)\n      if(kval >= 1.0) then\n        kval = 1.0\n        kstate = 1\n      endif\n      asig[kindx] = kval\n\n    elseif (kstate == 1) then\n      kval = kdecay_base + (kval * kdecay_coef)\n      if(kval <= ksustain) then\n        kval = ksustain\n        kstate = 2\n      endif\n      asig[kindx] = kval \n\n    else\n      asig[kindx] = ksustain\n    endif\n\n  else ; in a release state\n    kstate = 0\n    if (kval == 0.0) then\n      asig[kindx] = 0\n    else \n    ; releasing\n      kval = krelease_base + (kval * krelease_coef)\n    if(kval <= 0.0) then\n      kval = 0.0\n    endif\n    asig[kindx] = kval  \n    endif\n\n  endif\n\n  kindx += 1\nod\nxout asig\nendop\n\nopcode gatesig, a, ak\n  atrig, khold xin\n  kcount init 0\n  asig init 0\n  kndx = 0\n  kholdsamps = khold * sr\n  while (kndx < ksmps) do\n    if(atrig[kndx] == 1) then\n      kcount = 0\n    endif\n    asig[kndx] = (kcount < kholdsamps) ? 1 : 0 \n    kndx += 1\n    kcount += 1\n  od\n  xout asig\nendop\n\nopcode seqsig, ak, akk[]\n  agate, karrlen, kpattern[] xin\n  aout init 0\n  ;; karrlen = lenarray:k(kpattern)\n  kpatindx init (lenarray:i(kpattern) - 1)\n  kindx = 0\n  while (kindx < ksmps) do\n    if(agate[kindx] == 1) then \n      kpatindx = (kpatindx + 1) % karrlen\n    endif\n    aout[kindx] = kpattern[kpatindx]\n    kpatindxout = kpatindx\n    kindx += 1\n  od\n  xout aout, kpatindxout\nendop\n\n\nopcode seqsig, k, ak[]\n  agate, kpattern[] xin\n  kout init 0\n  karrlen = lenarray:k(kpattern)\n  kpatindx init (lenarray:i(kpattern) - 1)\n  kindx = 0\n  while (kindx < ksmps) do\n    if(agate[kindx] == 1) then \n      kpatindx = (kpatindx + 1) % karrlen\n      kout = kpattern[kpatindx]\n    endif\n    kindx += 1\n  od\n  xout kout\nendop\n\nopcode StrToArr, S[], SSS[]\n\n S_in, S_sep, S_Arr[] xin \n\n ;count the number of substrings\n kLenSep strlenk S_sep\n kPos = 0\n kPosShift = 0\n kCnt = 0\n\n while kPos != -1 do\n \n  kCnt += 1\n  S_sub strsubk S_in, kPosShift, -1\n  kPos strindexk S_sub, S_sep\n  kPosShift += kPos+kLenSep\n  \n od\n \n ;create a string array and put the substrings in it\n ;; S_Arr[] = kCnt\n kPos = 0\n kPosShift = 0\n kArrIndx = -1\n while kPos != -1 do\n \n  kArrIndx += 1\n  S_sub strsubk S_in, kPosShift, -1\n  kPos strindexk S_sub, S_sep\n  kEnd = (kPos == -1 ? -1 : kPosShift+kPos)\n  S_ToArr strsubk S_in, kPosShift, kEnd\n  kPosShift += kPos+kLenSep\n  S_Arr[kArrIndx] = S_ToArr  \n \n od\n \n  xout S_Arr\n\nendop\n\nopcode zdf_1pole, aa, ak\n  ain, kcf  xin\n\n  ; pre-warp the cutoff- these are bilinear-transform filters\n  kwd = 2 * $M_PI * kcf\n  iT  = 1/sr \n  kwa = (2/iT) * tan(kwd * iT/2) \n  kg  = kwa * iT/2 \n\n  ; big combined value\n  kG  = kg / (1.0 + kg)\n\n  ahp init 0\n  alp init 0\n\n  ;; state for integrators\n  kz1 init 0\n\n  kindx = 0\n  while kindx < ksmps do\n    ; do the filter, see VA book p. 46 \n    ; form sub-node value v(n) \n    kin = ain[kindx]\n    kv = (kin - kz1) * kG \n\n    ; form output of node + register \n    klp = kv + kz1 \n    khp = kin - klp \n\n    ; z1 register update\n    kz1 = klp + kv  \n\n    alp[kindx] = klp\n    ahp[kindx] = khp\n    kindx += 1\n  od\n\n  xout alp, ahp\nendop\n\n\n;; 1-pole (6dB) lowpass/highpass filter\n;; takes in a a-rate signal and cutoff value in frequency\nopcode zdf_1pole, aa, aa\n  ain, acf  xin\n\n  ; pre-warp the cutoff- these are bilinear-transform filters\n  iT  = 1/sr \n\n  ahp init 0\n  alp init 0\n\n  ;; state for integrators\n  kz1 init 0\n\n  kindx = 0\n  while kindx < ksmps do\n    ; pre-warp the cutoff- these are bilinear-transform filters\n    kwd = 2 * $M_PI * acf[kindx]\n    kwa = (2/iT) * tan(kwd * iT/2) \n    kg  = kwa * iT/2 \n\n    ; big combined value\n    kG  = kg / (1.0 + kg)\n\n    ; do the filter, see VA book p. 46 \n    ; form sub-node value v(n) \n    kin = ain[kindx]\n    kv = (kin - kz1) * kG \n\n    ; form output of node + register \n    klp = kv + kz1 \n    khp = kin - klp \n\n    ; z1 register update\n    kz1 = klp + kv  \n\n    alp[kindx] = klp\n    ahp[kindx] = khp\n    kindx += 1\n  od\n\n  xout alp, ahp\nendop\n\n;; 1-pole allpass filter\n;; takes in an a-rate signal and corner frequency where input\n;; phase is shifted -90 degrees\nopcode zdf_allpass_1pole, a, ak\n  ain, kcf xin\n  alp, ahp zdf_1pole ain, kcf\n  aout = alp - ahp\n  xout aout\nendop\n\n\n;; 1-pole allpass filter\n;; takes in an a-rate signal and corner frequency where input\n;; phase is shifted -90 degrees\nopcode zdf_allpass_1pole, a, aa\n  ain, acf xin\n  alp, ahp zdf_1pole ain, acf\n  aout = alp - ahp\n  xout aout\nendop\n\n\n;; 2-pole (12dB) lowpass/highpass/bandpass filter\n;; takes in a a-rate signal, cutoff value in frequency, and\n;; Q factor for resonance\nopcode zdf_2pole,aaa,aKK\n\n  ain, kcf, kQ     xin\n\n  ; pre-warp the cutoff- these are bilinear-transform filters\n  kwd = 2 * $M_PI * kcf\n  iT  = 1/sr \n  kwa = (2/iT) * tan(kwd * iT/2) \n  kG  = kwa * iT/2 \n  kR  = 1 / (2 * kQ)\n\n  ;; output signals\n  alp init 0\n  ahp init 0\n  abp init 0\n\n  ;; state for integrators\n  kz1 init 0\n  kz2 init 0\n\n  ;;\n  kindx = 0\n  while kindx < ksmps do\n    khp = (ain[kindx] - (2 * kR + kG) * kz1 - kz2) / (1 + (2 * kR * kG) + (kG * kG))\n    kbp = kG * khp + kz1\n    klp = kG * kbp + kz2\n\n    ; z1 register update\n    kz1 = kG * khp + kbp  \n    kz2 = kG * kbp + klp  \n\n    alp[kindx] = klp\n    ahp[kindx] = khp\n    abp[kindx] = kbp\n    kindx += 1\n  od\n\n  xout alp, abp, ahp\n\nendop\n\n\n;; 2-pole (12dB) lowpass/highpass/bandpass filter\n;; takes in a a-rate signal, cutoff value in frequency, and\n;; Q factor for resonance\nopcode zdf_2pole,aaa,aaa\n\n  ain, acf, aQ     xin\n\n  iT  = 1/sr \n\n  ;; output signals\n  alp init 0\n  ahp init 0\n  abp init 0\n\n  ;; state for integrators\n  kz1 init 0\n  kz2 init 0\n\n  ;;\n  kindx = 0\n  while kindx < ksmps do\n\n    ; pre-warp the cutoff- these are bilinear-transform filters\n    kwd = 2 * $M_PI * acf[kindx]\n    kwa = (2/iT) * tan(kwd * iT/2) \n    kG  = kwa * iT/2 \n\n    kR = 1 / (2 * aQ[kindx]) \n\n    khp = (ain[kindx] - (2 * kR + kG) * kz1 - kz2) / (1 + (2 * kR * kG) + (kG * kG))\n    kbp = kG * khp + kz1\n    klp = kG * kbp + kz2\n\n    ; z1 register update\n    kz1 = kG * khp + kbp  \n    kz2 = kG * kbp + klp \n\n    alp[kindx] = klp\n    ahp[kindx] = khp\n    abp[kindx] = kbp\n    kindx += 1\n  od\n\n  xout alp, abp, ahp\n\nendop\n\n;; 2-pole (12dB) lowpass/highpass/bandpass/notch filter\n;; takes in a a-rate signal, cutoff value in frequency, and\n;; Q factor for resonance\nopcode zdf_2pole_notch,aaaa,aKK\n\n  ain, kcf, kQ     xin\n\n  ; pre-warp the cutoff- these are bilinear-transform filters\n  kwd = 2 * $M_PI * kcf\n  iT  = 1/sr \n  kwa = (2/iT) * tan(kwd * iT/2) \n  kG  = kwa * iT/2 \n  kR  = 1 / (2 * kQ)\n\n  ;; output signals\n  alp init 0\n  ahp init 0\n  abp init 0\n  anotch init 0\n\n  ;; state for integrators\n  kz1 init 0\n  kz2 init 0\n\n  ;;\n  kindx = 0\n  while kindx < ksmps do\n    kin = ain[kindx]\n    khp = (kin - (2 * kR + kG) * kz1 - kz2) / (1 + (2 * kR * kG) + (kG * kG))\n    kbp = kG * khp + kz1\n    klp = kG * kbp + kz2\n    knotch = kin - (2 * kR * kbp)\n\n    ; z1 register update\n    kz1 = kG * khp + kbp  \n    kz2 = kG * kbp + klp  \n\n    alp[kindx] = klp\n    ahp[kindx] = khp\n    abp[kindx] = kbp\n    anotch[kindx] = knotch\n    kindx += 1\n  od\n\n  xout alp, abp, ahp, anotch\n\nendop\n\n;; 2-pole (12dB) lowpass/highpass/bandpass/notch filter\n;; takes in a a-rate signal, cutoff value in frequency, and\n;; Q factor for resonance\nopcode zdf_2pole_notch,aaaa,aaa\n\n  ain, acf, aQ     xin\n\n  iT  = 1/sr \n\n  ;; output signals\n  alp init 0\n  ahp init 0\n  abp init 0\n  anotch init 0\n\n  ;; state for integrators\n  kz1 init 0\n  kz2 init 0\n\n  ;;\n  kindx = 0\n  while kindx < ksmps do\n\n    ; pre-warp the cutoff- these are bilinear-transform filters\n    kwd = 2 * $M_PI * acf[kindx]\n    kwa = (2/iT) * tan(kwd * iT/2) \n    kG  = kwa * iT/2 \n\n    kR = 1 / (2 * aQ[kindx])\n\n    kin = ain[kindx]\n    khp = (kin - (2 * kR + kG) * kz1 - kz2) / (1 + (2 * kR * kG) + (kG * kG))\n    kbp = kG * khp + kz1\n    klp = kG * kbp + kz2\n    knotch = kin - (2 * kR * kbp)\n\n    ; z1 register update\n    kz1 = kG * khp + kbp  \n    kz2 = kG * kbp + klp \n\n    alp[kindx] = klp\n    ahp[kindx] = khp\n    abp[kindx] = kbp\n    anotch[kindx] = knotch\n    kindx += 1\n  od\n\n  xout alp, abp, ahp, anotch\n\nendop\n\n;; moog ladder\n\nopcode zdf_ladder, a, akk\n\n  ain, kcf, kres     xin\n  aout init 0\n\n  kR = limit(1 - kres, 0.025, 1)\n\n  kQ = 1 / (2 * kR) \n\n  kwd = 2 * $M_PI * kcf\n  iT  = 1/sr \n  kwa = (2/iT) * tan(kwd * iT/2) \n  kg  = kwa * iT/2 \n\n  kk = 4.0*(kQ - 0.707)/(25.0 - 0.707)\n\n  kg_2 = kg * kg\n  kg_3 = kg_2 * kg\n\n  ; big combined value\n  ; for overall filter\n  kG  = kg_2 * kg_2  \n  ; for individual 1-poles\n  kG_pole = kg/(1.0 + kg)\n\n  ;; state for each 1-pole's integrator \n  kz1 init 0\n  kz2 init 0\n  kz3 init 0\n  kz4 init 0\n\n  kindx = 0\n  while kindx < ksmps do\n    ;; processing\n    kin = ain[kindx]\n\n    kS = kg_3 * kz1 + kg_2 * kz2 + kg * kz3 + kz4\n    ku = (kin - kk *  kS) / (1 + kk * kG)\n\n    ;; 1st stage\n    kv = (ku - kz1) * kG_pole \n    klp = kv + kz1\n    kz1 = klp + kv\n\n    ;; 2nd stage\n    kv = (klp - kz2) * kG_pole \n    klp = kv + kz2\n    kz2 = klp + kv\n\n    ;; 3rd stage\n    kv = (klp - kz3) * kG_pole \n    klp = kv + kz3\n    kz3 = klp + kv\n\n    ;; 4th stage\n    kv = (klp - kz4) * kG_pole \n    klp = kv + kz4\n    kz4 = klp + kv\n\n    aout[kindx] = klp\n\n    kindx += 1\n  od\n\n  xout aout\nendop\n\n\nopcode zdf_ladder, a, aaa\n\n  ain, acf, ares     xin\n  aout init 0\n\n  iT  = 1/sr \n\n  ;; state for each 1-pole's integrator \n  kz1 init 0\n  kz2 init 0\n  kz3 init 0\n  kz4 init 0\n\n  kindx = 0\n  while kindx < ksmps do\n\n    kR = limit(1 - ares[kindx], 0.025, 1)\n\n    kQ = 1 / (2 * kR) \n\n    kwd = 2 * $M_PI * acf[kindx]\n    kwa = (2/iT) * tan(kwd * iT/2) \n    kg  = kwa * iT/2 \n\n    kk = 4.0*(kQ - 0.707)/(25.0 - 0.707)\n\n    kg_2 = kg * kg\n    kg_3 = kg_2 * kg\n\n    ; big combined value\n    ; for overall filter\n    kG  = kg_2 * kg_2  \n    ; for individual 1-poles\n    kG_pole = kg/(1.0 + kg)\n\n    ;; processing\n    kin = ain[kindx]\n\n    kS = kg_3 * kz1 + kg_2 * kz2 + kg * kz3 + kz4\n    ku = (kin - kk *  kS) / (1 + kk * kG)\n\n    ;; 1st stage\n    kv = (ku - kz1) * kG_pole \n    klp = kv + kz1\n    kz1 = klp + kv\n\n    ;; 2nd stage\n    kv = (klp - kz2) * kG_pole \n    klp = kv + kz2\n    kz2 = klp + kv\n\n    ;; 3rd stage\n    kv = (klp - kz3) * kG_pole \n    klp = kv + kz3\n    kz3 = klp + kv\n\n    ;; 4th stage\n    kv = (klp - kz4) * kG_pole \n    klp = kv + kz4\n    kz4 = klp + kv\n\n    aout[kindx] = klp\n\n    kindx += 1\n  od\n\n  xout aout\nendop\n\n;; 4-pole\n\nopcode zdf_4pole, aaaaaa, akk\n  ain, kcf, kres xin\n\n  alp2, abp2, ahp2 zdf_2pole ain, kcf, kres\n\n  abp4 init 0\n  abl4 init 0\n  alp4 init 0\n\n  xout alp2, abp2, ahp2, alp4, abl4, abp4\nendop\n\nopcode zdf_4pole, aaaaaa, aaa\n  ain, acf, ares xin\n\n  alp2, abp2, ahp2 zdf_2pole ain, acf, ares\n  abp4 init 0\n  abl4 init 0\n  alp4 init 0\n\n  xout alp2, abp2, ahp2, alp4, abl4, abp4\nendop\n\n\nopcode zdf_4pole_hp, aaaaaa, akk\n  ain, kcf, kres xin\n\n  alp2, abp2, ahp2 zdf_2pole ain, kcf, kres\n\n  ahp4 init 0\n  abh4 init 0\n  abp4 init 0\n\n  xout alp2, abp2, ahp2, abp4, abh4, ahp4\nendop\n\nopcode zdf_4pole_hp, aaaaaa, aaa\n  ain, acf, ares xin\n\n  alp2, abp2, ahp2 zdf_2pole ain, acf, ares\n\n  ahp4 init 0\n  abh4 init 0\n  abp4 init 0\n\n  xout alp2, abp2, ahp2, abp4, abh4, ahp4\nendop\n\n;; TODO - implement\nopcode zdf_peak_eq, a, akkk\n  ain, kcf, kres, kdB xin\n\n  aout init 0\n\n  xout aout\nendop\n\nopcode zdf_high_shelf_eq, a, akk\n  ain, kcf, kdB xin\n\n  ;; TODO - convert db to K, check if reusing zdf_1pole is sufficient\n  kK init 0\n\n  alp, ahp zdf_1pole ain, kcf\n\n  aout = ain + kK * ahp\n\n  xout aout\nendop\n\nopcode zdf_low_shelf_eq, a, akk\n  ain, kcf, kdB xin\n\n  ;; TODO - convert db to K, check if reusing zdf_1pole is sufficient\n  kK init 0\n\n  alp, ahp zdf_1pole ain, kcf\n\n  aout = ain + kK * alp\n\n  xout aout\nendop\n\n";
